\section{API}

We now describe the API that fulfills the requirements
outlined in Section~\ref{requirements} and builds upon the concepts
discussed in Section~\ref{concepts}.
The API is designed to be externally consistent when possible,
featuring a series of standard CRUD methods for manipulating objects:
\texttt{put}, \texttt{get}, \texttt{patch}, and \texttt{delete},
as well as straightforward methods for \texttt{login} and \texttt{logout}.
Most of the novel functionality is packaged into the \texttt{discover} method, which allows
users to query for objects from a set of channels.
Finally, there are two specialized methods included for completeness:
\texttt{recoverOrphans} and \texttt{channelStats},
which prevent users from ``losing'' objects or channels, respectively.

The API is written as an abstract Typescript \texttt{Graffiti} class.
Its complete documentation is available online\footnote{
    \url{https://api.graffiti.garden/classes/Graffiti.html}
} and so here we focus on explaining our design decisions.
Typescript is a type annotation layer around standard Javascript
and gives developers the option of type safety in their projects,
while still being completely accessible to normal developers:
implementations of the API can run directly in the browser with
no build step.
We later describe additional tools that make it even easier (Vue Plugin)
Type safety, which can be invaluable when working with multiple and
evolving object
however the API can be used.
The abstract part of the class allows different implementations of
the API, which may use different or multiple protocols,
to

Overall, as much complexity is pushed \emph{below} the API
while as much functionality is pushed \emph{above}.
Self-describing objects and channels push a lot of expressive
power above the API, while URLs, our login, continue push
things below
Hidden by the "URL" concept, not having to think about where stuff is stored.
Might open popup on first time to ask "where to store this?"
Hidden by discover returning just a "cursor" rather than new polling functionality.
Hidden by login() logout() functions with the flow.

\subsection{Logging In}

While it is possible to retrieve public content without logging in,
all other functionality, including
creating and modifying content or reading access-controlled content,
requires proof that the user owns a particular \emph{actor},
as described in Section~\ref{concepts:actor}, thus requiring a login.
% requires a login.
% The goal of logging in is to establish the user's ownership of a
% a particular \texttt{actor} URI, as described in Section~\ref{concepts:actor}.

Modern log in methods, like OAuth 2.0, while secure, are incredibly complex.
To hide this complexity from application developers and to make the API future proof
to evolving security standards, the API provides a simple \texttt{login} method that works as follows:

\begin{enumerate}
\item
A user performs an action, like clicking a ``log in'' button, that triggers
the application to call \texttt{graffiti.login()} (with \emph{no} arguments).
\item
In response, the implementation of the API may do any manner of things,
including opening up a pop up or redirecting the user to a new page.
In that implementation-specific interface, which the application developer
does not need to build, they might be asked for credentials like a username
and password, a public key pair, etc.
\item
Once the user is authenticated they are redirected back to the application, if applicable,
and a Javascript \emph{event} fires that includes
a \texttt{session} object. The \texttt{session} object includes an \texttt{actor}
URI and other information that the implentation needs to preserve authentication, like
a token or a signing function, however those details are entirely opaque to the application developer.
\item
When the application wants to perform an action that requires authentication,
it must provide the \texttt{session} object. For example,
\texttt{graffiti.delete(object, session)}.
\item
Finally, to log out, a user simply needs to call \texttt{logout} on the appropriate
\texttt{session} object: \texttt{graffiti.logout(session)}.
\end{enumerate}

We chose to keep the \texttt{session} object external from the \texttt{graffiti} class
to prevent developer mode errors, where an application attempts to perform an action
that requires authentication without asking the user to log in first.
These mode errors are detected by static type checking.
A seperate \texttt{session} object also allows an application to be logged in to
multiple actors at once, which can be useful for managing pseudonyms for anonymous interactions.

% To provide

% In addition to identifying the owner of particular objects,
% an actor URI may also be used as a channel
% or used in reified actions regarding the actor, like ``following'' the actor.

% However, that change should
% However, regardless of the underlying identity system,
% as much of the complexity as possible should be hidden from
% application developers.

% Today on the web most application provide log in throught the OAuth 2.0
% protocol. While this protocol provides security, it is extremely complex
% and it should not be up to users to understand and implement it correctly.
% Instead we provide the user with simple \texttt{login} and \texttt{logout} methods.


% Ideally we would like the system here to be portable across different implementations.
% Unfortunately, at the mome

% A user clicks a "log in" button in an application which trigger the login() method
%     A user interface appears, either as a dialog or a redirect, and asks for some user credentials.
%         In our federated implementation, we use Solid OIDC. First, a dialog opens and the user is asked to choose an identity provider, for example https://login.inrupt.com or https://solidcommunity.net. Then, they are redirected to that provider and must enter a username and password. After submitting, they are redirected back to the application.
%         In our local implementation (where the operations store and fetch data from local storage), a popup appears that asks what username a user would like. They do not need to supply any additional information.
%         In a distributed implementation (which we have not implemented), the user might be prompted to select a certificate containing a public keypair. They would not need to interface with a remote server because the certificate authenticates itself.
%     Once a user enters and submits their information, if successful, a GraffitiLoginEvent will fire. This will contain the GraffitiSession object. The session object contains, at the very least, an "actor" field which is a URI identifying the user. It may also include additional information. For example:
%         In our federated implementation, the "actor" field is their webId, a globally unique URL. For example mine is https://solid.theias.place/profile/card#me. The session also contains a token that the user can use to authenticate with any storage server. So regardless of whether I try to contact https://pod.graffiti.garden or https://graffiti.theias.place, both servers will be able to correctly verify that I am indeed https://solid.theias.place/profile/card#me. They can use that identity to know whether I am allowed to access access-controlled information, etc.
%         In our local implementation, the "actor" field just includes the username that the user specified. The session doesn't contain any other information because there is no other entity that needs proof that the user owns that username - everything is local, so they own everything.
%         In a (hypothetical) distributed implementation, the "actor" field could be the hash of the user's public key. The session would also include the the user's private key (or more securely a "signing function" and "decrypt function" so that client applications don't have direct access to the private key). The session can be used to sign objects the user creates to prove they own them, or decrypt objects that only the user is allowed to see.

% They provide strong typing even in an object of flexible envireonemtn
% We would like to rely on an existing standard for identity,
% but none so far exist and we point to future work in that
% area.
% As we are building on JSON Schema, it would be nice to also build on
% an existing standard for login. Unfortunately, one does not currently
% exist that suits are needs.
% As mentioned, it would be nice to build on an existing and
% well used standard for login. There is an emerging specification
% called DID, however it lets the user authenticate with \emph{one}
% service. We would like different services or even protocols.
% In our implementations we use an older speicification Solid OIDC,
% which has some serious usability limitations and is not flexible,
% but at least provides the high level functionality we would like.
% However we can not say with confidence that the

\subsection{Objects and CRUD}

Objects, as described in section~\ref{concepts:objects} encapsulate
all of the data in Graffiti.
They include the following meta properties:
\begin{enumerate}
\item
\texttt{value} (object): The actual data, which can be any JSON object.
\item
\texttt{url} (string): A string to uniquely identify and locate the object.
\item
\texttt{actor} (string): The URI of the actor that created the object.
\item
\texttt{allowed} (array of strings): A list of actors URIs that are allowed to access the object.
\item
\texttt{channels} (array of strings): A list of channels that the object is contained in, see Section~\ref{concepts:channels}).
\item
\texttt{lastModified} (number): A time to compare object versions.
\end{enumerate}

Subtly, the \texttt{channels} and \texttt{allowed} do not necessarily
reflect all the channels an object is contained in or
all the actors that can access the object.
Like a BCC email, it can be useful to send a message to multiple parties
without revealing their existence to one another to prevent
context collapse.
So both \texttt{channels} and \texttt{allowed} are \emph{masked} to
actors that do not own the object, however an application can always
add metadata to the object's \texttt{value} that reveals this information.

Additionally, the API builds on existing JSON Schema standard~\cite{jsonschema}.
This is a well established method and we use a library that
provides strong typing based on schemas.
These objects can be interacted with through standard CRUD methods:
\texttt{put}, \texttt{get}, \texttt{patch}, and \texttt{delete}.
\texttt{get} requires a JSON schema to ensure that the object
retrieved is of the correct type and \texttt
\texttt{patch} and JSONPatch~\cite{jsonpatch} and allows users to update
concurrently for example if they are using different devices.
\texttt{delete} removes an object from the system but some amount of
metadata is preserved.

\subsection{Discover}

The choice to not keep it live was intentional.

pass in a JSON schema. This does \emph{not} need to be the same schema a user
used when creating the object. For example, a user might be putting objects that
have.
As an example, here is a discover call for direct messages from
a user with actor ID

\begin{lstlisting}[language=javascript]
const iterator = graffiti.discover(
  [session.actor], // Look in "my" channel
  {
    value: {
      properties: {
        content: { type: "string" },
        createdAt: { type: "number" },
        to: { enum: [session.actor] }
      }
    },
    actor: { enum: ["alice"] }
  },
  session
)

for await (const object of iterator) {
  console.log(object.value.content);
}
\end{lstlisting}

Common schemas might include

At the end it returns a cursor and continue method.
These hide the complexity of state management below the API.
Also leaves open the possibility of different protocols having different state to maintain.
This continuation is the only situation where tombstones are returned.
They only contain the URL of the object in question, preserving the users right to be forgotten.

discover needs to be polled for new data because live updates to an application can be visually distracting or lead to toxic engagement. If and when an application wants real-time updates, such as in a chat application, application authors must be intentional about their polling.

Implementers should be aware that some users may applications may try to poll discover repetitively. They can deal with this by rate limiting or preemptively fetching data via a bidirectional channel, like a WebSocket. Additionally, implementers should probably index the lastModified field to speed up responses to schemas like the one above.

"Paging" is done by specifying a schema with a "lastModified" done appropriately.
There may be paging done by the underlying implementation!
Also the continue.

\subsection{Recovery Methods}

One key component of Graffiti is that users cannot get objects
unless they know either their URLs or one the channels the object
is contained in.
However this can lead to users losing objects if their applications
lose their URLs. It is also possible for a channel to have a typo.

Therefore the two methods \texttt{recoverOrphans} and \texttt{channelStats}
allow a user to get a global view of their \emph{own} Graffiti usage.
\texttt{recoverOrphans} works much like discover but finds objects
a user has created that are not contained in \emph{any} channel.
\texttt{channelStats} gives a user a high level overview of all the
channels that they've posted in.
