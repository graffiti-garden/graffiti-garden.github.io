\section{API}

We now describe the API that fulfills the requirements
outlined in Section~\ref{requirements} and builds upon the concepts
discussed in Section~\ref{concepts}.
The API is designed to be externally consistent when possible,
featuring a series of standard CRUD methods for manipulating objects:
\texttt{put}, \texttt{get}, \texttt{patch}, and \texttt{delete},
as well as straightforward methods for \texttt{login} and \texttt{logout}.
Most of the novel functionality is packaged into the \texttt{discover} method, which allows
users to query for objects from a set of channels.
Finally, there are two specialized methods included for completeness:
\texttt{recoverOrphans} and \texttt{channelStats},
which prevent users from ``losing'' objects or channels, respectively.

The API is written as an abstract Typescript class.
Its complete documentation is available online\footnote{
    \url{https://api.graffiti.garden/classes/Graffiti.html}
} and so here we focus on explaining our design decisions.
Typescript is a type annotation layer around standard Javascript
and gives developers the option of type safety in their projects,
while still being completely accessible to normal developers:
implementations of the API can run directly in the browser with
no build step.
We later describe additional tools that make it even easier (Vue Plugin)
Type safety, which can be invaluable when working with multiple and
evolving object
however the API can be used.
The abstract part of the class allows different implementations of
the API, which may use different or multiple protocols,
to

Overall, as much complexity is pushed \emph{below} the API
while as much functionality is pushed \emph{above}.
Self-describing objects and channels push a lot of expressive
power above the API, while URLs, our login, continue push
things below

\subsection{Log In and Log Out}

While it is possible to retrieve public content without logging in,
all other functionality, including
creating and modifying content or reading access-controlled content,
requires a login.
The goal of logging in is to establish the user's ownership of a
a particular \texttt{actor} URI, as described in Section~\ref{concepts:actor}.
In addition to identifying the owner of particular objects,
an actor URI may also be used as a channel
or used in reified actions regarding the actor, like ``following'' the actor.

To enable interoperability, the login procedure must be portable
so that a user can log in with the
same identity across different applications.
Ideally, login also be portable across different underlying
\emph{protocols} that implement the API.
For example, it should be possible a actor who stores their data on
commodity storage service, like Dropbox, to send a private message
% (by creating an object with an \emph{allowed} list)
to an actor who stores their data on a peer-to-peer network.
Unfortunately, such a universal identity standard does not yet exist
and developing one is outside the scope of this paper.
The Decentralized Identifier (DID) specification~\cite{dids} may serve this purpose one day,
but currently has shortcomings listed in Section~\ref{protocols}.

However, that change should
However, regardless of the underlying identity system,
as much of the complexity as possible should be hidden from
application developers.

Today on the web most application provide log in throught the OAuth 2.0
protocol. While this protocol provides security, it is extremely complex
and it should not be up to users to understand and implement it correctly.
Instead we provide the user with simple \texttt{login} and \texttt{logout} methods.

\begin{enumerate}
\item
A user clicks a button which the devloper has call \texttt{login()}
\item
In repsonse, the implementation of the API may do any manner of things,
including opening up a pop up including redirecting the user to a new page
to ask for credentials like a username or password, or a public key pair.
\item
Once the action completes, which may involve redirecting away, an event fires
providing a \texttt{session} object which includes an \texttt{actor} URI
in addition to other information. This might be a token, a signing function,
\item
When the user wants to do an action they must provide their \texttt{session}
\end{enumerate}

Using the \texttt{session}
The seperate sesssion helps with type-safety and also allows the possibility of multiple logins
at once, if a user.
The session might contain a token, or it might contain cababilities, or it might include a private key.

Ideally we would like the system here to be portable across different implementations.
Unfortunately, at the mome

% A user clicks a "log in" button in an application which trigger the login() method
%     A user interface appears, either as a dialog or a redirect, and asks for some user credentials.
%         In our federated implementation, we use Solid OIDC. First, a dialog opens and the user is asked to choose an identity provider, for example https://login.inrupt.com or https://solidcommunity.net. Then, they are redirected to that provider and must enter a username and password. After submitting, they are redirected back to the application.
%         In our local implementation (where the operations store and fetch data from local storage), a popup appears that asks what username a user would like. They do not need to supply any additional information.
%         In a distributed implementation (which we have not implemented), the user might be prompted to select a certificate containing a public keypair. They would not need to interface with a remote server because the certificate authenticates itself.
%     Once a user enters and submits their information, if successful, a GraffitiLoginEvent will fire. This will contain the GraffitiSession object. The session object contains, at the very least, an "actor" field which is a URI identifying the user. It may also include additional information. For example:
%         In our federated implementation, the "actor" field is their webId, a globally unique URL. For example mine is https://solid.theias.place/profile/card#me. The session also contains a token that the user can use to authenticate with any storage server. So regardless of whether I try to contact https://pod.graffiti.garden or https://graffiti.theias.place, both servers will be able to correctly verify that I am indeed https://solid.theias.place/profile/card#me. They can use that identity to know whether I am allowed to access access-controlled information, etc.
%         In our local implementation, the "actor" field just includes the username that the user specified. The session doesn't contain any other information because there is no other entity that needs proof that the user owns that username - everything is local, so they own everything.
%         In a (hypothetical) distributed implementation, the "actor" field could be the hash of the user's public key. The session would also include the the user's private key (or more securely a "signing function" and "decrypt function" so that client applications don't have direct access to the private key). The session can be used to sign objects the user creates to prove they own them, or decrypt objects that only the user is allowed to see.

Identities should be portable between applicaiton but ideally they
should be portable between protocols. A universal protocol DIDs
seem like they will fit this, although currently they do not have authentication.
Graffiti is built on Solid OIDC as portable identity but others can be in the future.
Alternatively, non-interoperating identities are possible (e.g. dropbox) but this is restricting.
Ideally, identities should be portable regar
Importantly, identities should be portable regardless of

They provide strong typing even in an object of flexible envireonemtn
We would like to rely on an existing standard for identity,
but none so far exist and we point to future work in that
area.
As we are building on JSON Schema, it would be nice to also build on
an existing standard for login. Unfortunately, one does not currently
exist that suits are needs.
As mentioned, it would be nice to build on an existing and
well used standard for login. There is an emerging specification
called DID, however it lets the user authenticate with \emph{one}
service. We would like different services or even protocols.
In our implementations we use an older speicification Solid OIDC,
which has some serious usability limitations and is not flexible,
but at least provides the high level functionality we would like.
However we can not say with confidence that the

\subsection{Objects and CRUD}

Objects, as described in section~\ref{concepts:objects} encapsulate
all of the data in Graffiti.
They include a \texttt{value} property which is a freeform JSON object,
a \texttt{url} property which is a string,
a \texttt{channels} property which is an array of strings,
an \texttt{allowed}
The one additional piece of metadata not described in the concepts
is the \texttt{lastModified} property which is used to compare object version.

Dealing with objects can be typed.
Additionally, the API builds on existing JSON Schema standard~\cite{jsonschema}.
This is a well established method and we use a library that
provides strong typing based on schemas.

These objects can be interacted with through standard CRUD methods:
\texttt{put}, \texttt{get}, \texttt{patch}, and \texttt{delete}.
\texttt{get} requires a JSON schema to ensure that the object
retrieved is of the correct type and \texttt
\texttt{patch} and JSONPatch~\cite{jsonpatch} and allows users to update
concurrently for example if they are using different devices.
\texttt{delete} removes an object from the system but some amount of
metadata is preserved.

\subsection{Discover}

The choice to not keep it live was intentional.

At the end it returns a cursor and continue method.
These hide the complexity of state management below the API.
Also leaves open the possibility of different protocols having different state to maintain.
This continuation is the only situation where tombstones are returned.
They only contain the URL of the object in question, preserving the users right to be forgotten.

discover needs to be polled for new data because live updates to an application can be visually distracting or lead to toxic engagement. If and when an application wants real-time updates, such as in a chat application, application authors must be intentional about their polling.

Implementers should be aware that some users may applications may try to poll discover repetitively. They can deal with this by rate limiting or preemptively fetching data via a bidirectional channel, like a WebSocket. Additionally, implementers should probably index the lastModified field to speed up responses to schemas like the one above.

\subsection{Recovery Methods}

One key component of Graffiti is that users cannot get objects
unless they know either their URLs or one the channels the object
is contained in.
However this can lead to users losing objects if their applications
lose their URLs. It is also possible for a channel to have a typo.

Therefore the two methods \texttt{recoverOrphans} and \texttt{channelStats}
allow a user to get a global view of their \emph{own} Graffiti usage.
\texttt{recoverOrphans} works much like discover but finds objects
a user has created that are not contained in \emph{any} channel.
\texttt{channelStats} gives a user a high level overview of all the
channels that they've posted in.

\subsection{Hiding Complexity}

Hidden by the "URL" concept, not having to think about where stuff is stored.
Might open popup on first time to ask "where to store this?"
Hidden by discover returning just a "cursor" rather than new polling functionality.
Hidden by login() logout() functions with the flow.
