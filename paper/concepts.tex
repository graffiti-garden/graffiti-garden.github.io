% \section{Design Overview and Concepts}
\section{Design Concepts}

This section outlines the high level concepts that make up the design of Graffiti
according to the requirements we outlined in section \ref{requirements}.
Section~\ref{api} outlines the specific API that is built out of these
concepts and section~\ref{protocols} various protocols that implement the API.

At a high level the design works as follows.
\emph{Actors} (basically users) create \emph{objects} which can represent
social artifacts like posts or activities like "likes".
Objects are associated with a set of \emph{channels} and other users can
discover an object by querying one of its channels. Channels are flexible representation
of different \emph{contexts} which may include identities, topics, piece of media, locations, etc.
Users can only modify their own objects and so to for users to interact with each other's content
those interactions are \emph{reified} into indivdual
activies according to a principle we call \emph{interaction relativity}.

\subsection{Actors}

An actor is a persistent and globally unique identifier.
In most cases an actor can be considered synonymous with a user,
however, like an email adress, a user can own multiple actors
or actors may be non-human entities like bots or recommendation services.
The term \emph{actor} was originally used for this purpose
in the ActivityPub standard~\cite{activitypub}.

A user can ``log in'' to an actor and then publish as that actor.
It is not possible for one user to impersonate another user's actor.
Importantly, to enable interoperability
as required by \ref{requirements:adversarial-interop},
a Graffiti actor is not tied to any particular application so that users can freely move between
different applications.

A Graffiti actor does not include any information other than its
global identifier. For example, an actor does not have a global
name, profile picture, or biography associated with it.
Instead, profiles are defined by seperate profile \emph{objects}
(described in the following Section~\ref{concepts:objects}),
allowing applications to freely introduce new profile
metadata or for users to have multiple profiles for different contexts
making profiles autonomously extensible as required by \ref{requirements:autonomous-extensibility}.
For example, a trans person who is not publicly ``out'' may want to
% add pronoun metadat to their profile and
change their name within theirr queer community without
changing their name to the broader public.
% Objects and their relation to autonomous extensibility are described next.

All interactions must be associated with an actor, but
for anonymous or meronymous~\cite{meronymous} interactions,
a person can create ``throw away'' actors.

\subsection{Objects}
\label{concepts:objects}

Objects are the atomic units that encapsulate \emph{all}
of the social data in the system, including
both social artifacts (such as posts and profiles) and social activities (such as likes and follows).
Each Graffiti object includes some structured metadata,
such as the actor who created the object,
but an object's value can be \emph{any} valid JSON.
For example, a blog post object may have the value:

\begin{lstlisting}[language=javascript]
{
  title: "My First Post",
  content: "Hello, world!",
  published: 1611972000, // The time in seconds
}
\end{lstlisting}

The ActivityVocabulary~\cite{activityvocab},
whose object model inspired our own,
defines many common properties that are useful for social applications including
the ones above.
However, application developers can freely introduce new properties as necessary
as part of an evolving \emph{folksonomy}~\cite{folksonomy}.
We leverage the fact that JSON can be \emph{self-describing}
--- a message can contain structured data with arbitrary properties and
values that are irrelevant and opaque to the delivery infrastructure but
meaningful to specific clients.
For example, an application for sharing recipes might introduce a new
\texttt{ingredients} property.

Because social applications
benefit from network effects, we expect that developers will make use of
existing properties where possible, allowing them them to benefit from pre-existing data
made in other applications, but will introduce new properties when necessary.
The result will inevitably be messy and inconsistent but, as with the evolution of
particular hashtags, we expect there will be an effective balance of creativity and convergence.
% This folksonomy is an effective mean of ensuring that objects are autonomously extensible.
% We also provide tooling that allows users to filter data and provide human-readable
% fallbacks for data they can't parse.

Graffiti objects are also globally addressable which allows them to be
pointed at and linked to.
% Like URLs, these addresses start with scheme which prevents collision
% between different protocols.
For example, a post might have the URI \texttt{graffiti:remote:pod.graffiti.garden/123},
enabling other users to ``like'' that post by creating a new object with the value:

\begin{lstlisting}[language=javascript]
{
  activity: "like",
  target: "graffiti:remote:pod.graffiti.garden/123",
}
\end{lstlisting}

This like activity is an example of \emph{reification},
a concept introduced by the semantic web community
which permits actions on data to be reprepresented as data themselves.
Rather than a post object being an object that has a ``like'' method,
the ``like'' here is a separate object that points to the post object.
Reification allows for new interaction mechanisms to be introduced as easily as new properties,
without changing the underlying system. In other systems only some interactions are reified,
but in Graffiti all interactions, including moderation actions, are reified,
a concept we call \emph{interaction relativity} which we discuss in the following
Section~\ref{concepts:interaction-relativity}.


Finally, objects are mutable, meaning that they can be changed or deleted,
and they can be access-controlled, visable to only a limited set of actors.
Mutability is necessary for the system to be forgiving as required by \ref{requirements:forgiving}.
The question of \emph{who} can mutate the objects is relevant to
interaction relativity which, again, we discuss in the following
Section~\ref{concepts:interaction-relativity}.
Access controls enables some affordances that mitigate context collapse,
like private messages, while others arise from the channels concept
which we discuss in Section~\ref{concepts:channels}.

In summary Graffiti objects are:

\begin{enumerate}
\item
Flexible: Objects can take on any value according to a self-describing folksonomy.
\item
Globally-Addressable: Every object has a globally unique URI that can be used to fetch it.
\item
Mutable: Objects can be changed or deleted.
\item
Access-Controllable: Objects can be made private and only visible to a limited set of actors.
% we add the two following contraints on objects
% \item
% Proprietary: Only the creator of an object can modify or delete it.
% \item
% Permissioned: Objects can have an allow list of users who can view them.
% \item
% Ducktyped: Objects have no type.
\end{enumerate}

% Mutable, proprietary, and permissioned are necessary for the right to be forgotten.
% \item
% Objects can be associated with one or more channels.
% \item
% You can either get an object by one of its channels or by its URI.

\subsection{Interaction Relativity}
\label{concepts:interaction-relativity}

We define interaction relativity to mean that ``interaction between two individuals only
exists relative to an application'' or equivalently that not some but \emph{all} interactions
are \emph{reified}.
For example, a like is not a method on an object.
So if an application does not underatnd the action and users don't see it, did the like really occur?

% if a person likes another person's post

% For example if an application \emph{A} is built to understand like objects,
% \emph{A} may tally up all like objects that point
% at a post and display the like count next to the post.
% Alternatively, an application \emph{B} may give poster the ability disable likes
% by adding a \texttt{disableLikes} property to their post objects
% causing \emph{B} to not display a like counter.
% A person's like may ``occur'' in \emph{A} but not in \emph{B}.
% From the perspecive of one application the like occurred and from the
% perspective of another it did not.
% Without applications to interpret the data, the post and like objects
% are disconnected and meaningless.
% Whether a user has liked another users post is relative to which
% application they use.

The introduction and interpretation of new properties and objects
that clarify whether an interaction has, or has not, occured
is entirely up to the application developers themselves.
This allows developers to freely introduce new interactions
as required by \ref{requirement:autonomous-extensibility} without
breaking interoperability as required by \ref{requirement:adversarial-interop}.

This concept is powerful when applied to moderation.
For example, suppose a developer would like to introduce a new application
that interoperates with an existing microblogging application,
but that allows certain users (moderators) to delete other users' posts.
If the deletes are reified, as shown below, the new application
can remove posts that the delete activities point to while the original
application simply ignores the delete activities.

\begin{lstlisting}[language=javascript]
{
  activity: "delete",
  target: "graffiti:remote:pod.graffiti.garden/123",
}
\end{lstlisting}

Moderation could evolve further as applications introduce new objects and properties
or new procedures to interpret those objects.
For example,
perhaps the set of moderators is elected by the users whose votes are reified activities.
Or, perhaps an application might remove posts that exceed a certain threshold of deletes activities,
regardless of whether the deleting users are considered moderators.
Applications may also consider authors of posts to be the defacto moderators of the replies to their
own posts or allow them to disable replies altogether by adding a \texttt{disableReplies}
property to their post objects.
A fully democratic system that allows users to introduce and ratify new moderation proposals,
as described by the PolicyKit project~\cite{policykit}, could also be reified into
individual user actions.
Importantly, all of these moderations systems can coexist in different interoperating
applications and users can freely opt in or out of different systems simply by switching
the application they use.
% can evolve independently and
% users can freely opt in or out of different
% procedures because all of the underlying interactions are reified.

% The introduction and ratification of new proposals

% This is similar to the concept of ``stackable moderation'' proposed by Bluesky~\cite{bluesky}
% but more general.
% In stackable moderation, users can choose which moderators they would like to filter their content.
% In interaction relativity, the application developer can choose which moderators they would like to filter their content.
% This is more general because the application developer can choose to filter content based on any reified activity,
% not just moderation actions.
% For example, day that a Moderator wants to delete another user's post.
% (Reference "issues with mastodon paper" which cites moderation issues
% locked into particular places, work redone, etc.)


% This helps with that paper that eric gilbert sent. Moderation as data.
% For example say that Alice wants to delete a post that Bob made.
% For moderation this is like composable moderation. But also more.
% For example, one application could have a single fixed moderator,
% another could allow users to choose which moderators they would like filter their content
% like [Bluesky's stackable moderation](https://bsky.social/about/blog/03-12-2024-stackable-moderation),
% and another could implement a fully democratic system like [PolicyKit](https://policykit.org/).
% Each of these applications is one interpretation of the underlying refieid user interactions and
% users can freely switch between them.

% Another example is collaboration. Say one user would like to modify
% Say a user would like to edit another user's post.
% a document but another would like to keep it the same. CRDTs.

Having flexible object values that we described in Section~\ref{concepts:objects} makes reifiecation \emph{possible}
but interaction relativity requires that not some but \emph{all} interactions
are relative, therefore reification must be \emph{necessary}
for interaction to take place.
For example, it should not be possible for a user to \emph{actually}
delete another user's post because that prevents different interpretations
from coexisting.
This violates the ``adversarial'' part of ``adversarial interoperability,''
from requirement~\ref{requirement:adversarial-interop}.
As such, we ensure that:
\begin{enumerate}
\item
Objects are \emph{proprietary}: only the creator of an object can modify or delete it.
\end{enumerate}
Conversely, developers should not be restricted from creating new objects and activities,
as this could hinder the introduction of new interactions.
Objects are published in channels, a concept we discuss in detail
in the following Section~\ref{concepts:channels}, and therefore
\begin{enumerate}
\setcounter{enumi}{1}
\item
Channels are \emph{ownerless}: no user can prevent any other user from reading from or writing to a channel.
\end{enumerate}

The fact that the API does not allow content to \emph{actually} be deleted
has consequences for illegal content, like CSAM.
However, it is possible for some implementations under the API to detect
and prevent this content which we discuss in both
Section~\ref{protocols} and Section~\ref{discussion}.
There is also some subtlety in how collaborative editing might be done under interaction relativity,
for systems like Wikipedia or Google Docs,
but we demonstrate in Section~\ref{case-studies} that
it is possible with the use of conflict-free replicated data types (CRDTs)~\cite{crdts}.

% which we discuss in our discussion.
% While we argue it is possible to make any social application
% with these properties there are implications for the fact that content
% cannot actualy be deleted of prevented.
% We discuss implications for illegal content, like CSAM, in our discussion.


\subsection{Channels}
\label{concepts:channels}

Channels are our solution to mitigating context collapse, as required by
\ref{requirements:context-differentiation}, when still being
interoperable as required by~\ref{requirements:adversarial-interop}.
Like a television channel, users can publish content (in Graffiti's case
the content is \emph{objects}, see~\ref{concepts:objects}) to a particular channel
and user watching that channel will receive it.
Unlike a television channel, Graffiti channels are:
\begin{enumerate}
\item
Bidirectional: Users can both read from and write to channels.
\item
Persistent: When a user publishes an object to a channel, other users can
continue to retrieve the object from the channel until it gets deleted.
\item
Global: The channel namespace is global with every string (up to a certain length)
corresponding to exactly one channel.
\item
Obscure: It is not possible to read from or write to a channel without knowing
its string.
\item
Crosspostable: An object can be associated with more than one channel (or no channel at all).
\end{enumerate}

Additionally, to enable interaction relativity, we mentioned preemptively that channels are ownerless.
Given the obscurity property, we should clarify:

\begin{enumerate}
\setcounter{enumi}{5}
\item
Ownerless: No user can prevent any other user from reading from or writing to a channel
\emph{that they know about}.
\end{enumerate}

IRC or Slack channels and Matrix rooms are similarly bidirectional and persistent
but are not global, obscure, ownerless, or crosspostable.
The World Wide Web is global, obscure, and persistent
but not bidirectional, ownerless, or crosspostable.

% The fact that channels are ownerless seems ripe for harm, but it is necessary for
% for moderation policies to be ``autonomously extensible'' as per requirement
% \ref{requirements:autonomous-extensibility}.
% This ownerless property is where the system gets its namesake.

% Moderation and other cases of automous extensibility are resolved by our
% notion of ``Interaction Relativity,'' \ref{concepts:interaction-relativity}.

\subsubsection{Replies}

To understand how channels can work to prevent context collapse, consider the example of \emph{replies}.
Many social applications allow you to reply to posts but there are suprisingly subtle
contextual differences between different reply designs.
For example, currently on Instagram
if you reply to a post that reply can only be seen by other
people also viewing that particular post.
However, prior to 2019 Instagram had a Following tab where a user could see
the comments that the people they followed had posted across the application.
The Following tab led to a priest outing himself as gay among numerous other
examples of context collapse~\cite{instagramfollowingtab}.
On Twitter/X it is still possible to see all of a user's replies by going
to their Replies tab.

With channels, it is possible for \emph{both} to designs to \emph{co}exist.
% preventing context collapse to those
% and
% the choice
% is up to the \emph{replier} rather than viewers of those replies.
To make an Instagram-style reply,
an application should post a user's reply to the channel
represented by the original post's URL.
Applications displaying the original post know its URL and therefore,
by convention, they can know to query that channel for replies.
% for replies but it won't be exposed to the rest of the user's followers.
To make an Twitter/X-style reply, the user would post their reply to \emph{both}
the channel represented by the original post's URL and
the channel represented by their own actor URI.
A user's followers all know a user's actor URI and so
(by convetion), they can know
A user's followers know to use a user's actor URI to see content related to that actor.

\begin{table}[htbp]
    \label{concepts:channel-replies}
    \begin{tabular}{c|c|c|c}
        \multicolumn{2}{c}{} & \multicolumn{2}{c}{\textbf{Post URL}} \\
        % \cline{3-4}
        \multicolumn{2}{c|}{} & \textbf{Yes} & \textbf{No} \\
        \hline
        \multirow{2}{*}{\textbf{Actor URI}} & \textbf{Yes} & Twitter/X Reply & Quote Tweet \\
        \cline{2-4}
        & \textbf{No} & Instagram Comment & N/A \\
        \hline
    \end{tabular}
    \caption{Channels and Replies}
\end{table}

Importantly context is preserved across interoperation.
If a user posts their reply in
an Instagram-like app they should expect that their reply will not be leaked even if
a user is using Twitter.
The choice is up to the user rather than

To make an Instagram-style reply, that reply should be posted to the channel
containing the original post's URI.
If we also place the comment in the channel represented by the commenter's URI (their
{@link GraffitiObjectBase.actor | `actor` URI}), then people viewing the commenter's profile
will also see the comment, giving it more visibility, like a reply on Twitter.
If we *only* place the comment in the channel represented by the commenter's URI, then
it becomes like a quote tweet ([prior to 2020](https://x.com/Support/status/1300555325750292480)),
where the comment is only visible to the commenter's followers but not the audience
of the original post.

\subsubsection{Other Uses of Channels}

We've seen how channels can represent \emph{people} and \emph{posts}
which covers the functionality of most microblogging applications,
but channels can also represent
media, topics, websites, locations, and more,
each of which can form the basis for a different class of
social application, as shown in Table~\ref{concepts:tab:channels}.

\begin{table}[h]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Channel} & \textbf{Application} \\ \hline
        External Media & Letterboxd, GoodReads, Genius, last.fm \\ \hline
        User-Created Media & SoundCloud, YouTube, Medium \\ \hline
        User-Generated Topics & Reddit, Discord, Slack, IRC \\ \hline
        User-Generated Collections & are.na, Pinterest, Spotify playlists \\ \hline
        Website & Hypothes.is, Pinboard, Delicious \\ \hline
        Physical Locations & Tinder, Nextdoor, Craigslist, YikYak \\ \hline
        Virtual Locations & VRChat, Second Life, Minecraft \\ \hline
        Events & Meetup, Partiful, Facebook Events \\ \hline
        Products and Services & Amazon reviews, Yelp \\ \hline
        Collaborative Documents & Wikipedia, Google Docs \\ \hline
    \end{tabular}
    \caption{Channels and Their Applications}
    \label{concepts:tab:channels}
\end{table}

In some cases the channel string is obvious, like the URL of a website (Hypothes.is),
or the ISBN of a book (GoodReads).
In other cases the channel string may be user generated, as with
public contexts like subreddits or a Wikipedia pages,
and in others they may be randomly generated for privacy, as with
a Discord channel, Pinterest board, or Google document.
Locations are interesting because they are a continuous space.
An agreed upon subdivision of space, like zip codes or what-three-words,
or a "resolution pyramid" where users could post at different
levels where they want.

Channels should be URI-like and are prepended with a scheme to prevent
collisions.

Channels can also represent \emph{application types themselves}.
For example, to avoid the issue of Linkedin and Tinder.
Channels can also be concatenated.
For example, `dating+location' would prevent other people from seeing th post.
Concatenation may also happen in natural language.
For example, on Reddit when one wants to post programming-related memes they post to \texttt{r/programmerhumor} rather than \texttt{r/programming+funny}.
These concatenations may themselves take on new meaning.

\subsubsection{Comparison to Other models}

While channels are a relatively simple, they are subtly differences from other established concepts:

The channel model is clearly different from the Firehose Model used by BlueSky
which.
The firehose model dumps all user data into one public database,
which doesn't allow for the carving out of different contexts that we did in our comment
example above. In the firehose model a comment will always be visible to *both* the original post's audience and
the commenter's followers.
It also has subtle differences.
There are several other contextual models.

\paragraph{Actor}

We use actors to describe identities in the system,
but ActivityPub uses the actor model to describe the system itself.
As mentioned the actor model used by ActivityPub is a fusion of
direct messaging (like Email) and broadcasting like RSS.
Having channels

Compared to the Actor Model it removes the need for Server-Side effects
The actor model is a fusion of direct messaging (like Email) and broadcasting
(like RSS) and works well for follow-based communication but struggles
to pass information via other rendez-vous.
In the actor model, even something as simple as comments can be
[very tricky and require server "side effects"](https://seb.jambor.dev/posts/understanding-activitypub-part-3-the-state-of-mastodon/).

\paragraph{Bidirectional Links}

On the World Wide Web, hyperlinks point in one direction from one website to another.
However earlier hypermedia systems, like Xanadu and Dexter, included \emph{bidirectional} links:
from one document you could see all the other documents that link to it.
Bidirecitonal links are now currently possible in personal information management systems like Roam and Notion.

Channels can be seen as a way to \emph{selectively} create bidirectional links.
A reply object will have pointers to the object it is replying to and the actor who created the reply.
Adding the object's URI or the actor's URI as channels selectively adds backlinks to those entities
making it possible to go \emph{from} the original post \emph{to} the reply (in the case of Instagram-like comments)
or \emph{from} the actor \emph{to} the reply (in the case of Twitter/X-like comments).
Of course, channels also make it possible to create "links" from non-digital artifacts like topics or locations.

\paragraph{Object Capabilities}

Object capability security (OCaps) is a security model where rights to perform an action
can be transferred to another user by giving that user a reference to that action.
Channels can be thought of as a capability mechanism where
capability read or write to a particular channel
can be transferred to another user by telling them the channel's string.

However Graffiti isn't a purely capability-based system because it
is also possible to add an "allow" list to each object.
For example a group chat could use a private string as a channel
and if that string is sufficiently long and random so as not to be guessed
the conversation would remain private.
However this makes it possible for any member of the group to share (or accidentally leak) the
channel and let anyone else in.
Allow lists provide more long term privacy.

Allow lists are managed by applications.
If allow lists are especially enourmous then is it really public?

\subsubsection{Social Access Control}

In some sense, channels provide a sort of "social access control" by forming
expectations about the audiences of different online spaces.
As a real world analogy, oftentimes support groups, such as alcoholics
anonymous, are open to the public but people in those spaces feel comfortable sharing intimate details
because they have expectations about the other people attending.
If someone malicious went to support groups just to spread people's secrets,
they would be shamed for violating these norms.
Similarly, in Graffiti, while you could spider public channels like a search engine
to find content about a person, revealing that you've done such a thing
would be shameful.

Still, social access control is not perfect and so in situations where privacy is important,
objects can also be given
an {@link GraffitiObjectBase.allowed | `allowed`} list.
For example, to send someone a direct message you should put an object representing
that message in the channel that represents them (their {@link GraffitiObjectBase.actor | `actor` URI}),
so they can find it, *and* set the `allowed` field to only include the recipient,
so only they can read it.
